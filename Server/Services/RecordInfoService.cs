using System.Net;
using PowerDNS_Auth_CouchDB_Remote_Backend.Brokers;
using PowerDNS_Auth_CouchDB_Remote_Backend.Extensions.HTTPClient;
using PowerDNS_Auth_CouchDB_Remote_Backend.Models;
using PowerDNS_Auth_CouchDB_Remote_Backend.Models.CouchDB;
using PowerDNS_Auth_CouchDB_Remote_Backend.Models.Services;

namespace PowerDNS_Auth_CouchDB_Remote_Backend.Services;

public class RecordInfoService : IRecordInfoService
{
    private readonly IAPIBroker _apiBroker;

    public RecordInfoService(IAPIBroker apiBroker)
    {
        _apiBroker = apiBroker;
    }

    public async Task<List<Record>?> ListRecordAsync(string queryName, CancellationToken token = default)
    {
        queryName = NormalizeQueryName(queryName);
        return await _apiBroker.ListRecordAsync(queryName, token);
    }

    public async Task<Record?> GetRecordByIdAsync(string recordId, CancellationToken token = default)
    {
        return await _apiBroker.GetRecordByIdAsync(recordId, token);
    }


    public async Task<List<Record>?> ListRecordByZoneIdAsync(uint zoneId, CancellationToken token = default)
    {
        return await _apiBroker.ListRecordByZoneIdAsync(zoneId, token);
    }

    public async Task<List<Record>?> GetRecordAsync(string queryName, string type, CancellationToken token = default)
    {
        queryName = NormalizeQueryName(queryName);
        return await _apiBroker.GetRecordAsync(queryName, type, token);
    }

    public async Task<IOperationResult> SetRecordAsync(Record record, CancellationToken token = default)
    {
        var response = await _apiBroker.SetRecordAsync(record, token);
        if (response.IsSuccessStatusCode)
            return new GenericOperationResult<CouchDbOperationResult>(true, $"Successfully created {record}",
                HttpStatusCode.OK, await response.GetCouchDBOperationResult());
        // This shouldn't happen, since conflicts only occur on ID conflicts, and IDs for records are randomly generated by CouchDB, but just in case
        if (response.StatusCode == HttpStatusCode.Conflict)
            return new GenericOperationErrorResult(false, $"{record} already exists", HttpStatusCode.Conflict);

        // If anything else, throw and let the error handler middleware deal with it.
        response.EnsureSuccessStatusCode();
        // Error will be thrown before this anyway
        return new GenericOperationErrorResult(false, "Internal Error", HttpStatusCode.InternalServerError);
    }

    public async Task<IOperationResult> DeleteRecordAsync(Record record, CancellationToken token = default)
    {
        if (record.ID == null)
            return new GenericOperationErrorResult(false, "Record ID cannot be null", HttpStatusCode.BadRequest);

        var response = await _apiBroker.DeleteRecordAsync(record, token);
        if (response.IsSuccessStatusCode)
            return new GenericOperationResult<CouchDbOperationResult>(true, $"Successfully deleted {record.ID}",
                HttpStatusCode.OK, await response.GetCouchDBOperationResult());

        if (response.StatusCode == HttpStatusCode.NotFound)
            return new GenericOperationErrorResult(false, $"Could not find {record.ID}", HttpStatusCode.NotFound);

        // If anything else, throw and let the error handler middleware deal with it.
        response.EnsureSuccessStatusCode();
        // Error will be thrown before this anyway
        return new GenericOperationErrorResult(false, "Internal Error", HttpStatusCode.InternalServerError);
    }

    public static string NormalizeQueryName(string queryName)
    {
        if (queryName.EndsWith("."))
            return queryName.Remove(queryName.Length - 1);
        return queryName;
    }
}